{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Book of BDK","text":"<p>The Bitcoin Development Kit (BDK) project was created to provide well engineered and reviewed components for building bitcoin-based applications.</p> <p>The core components of BDK are written in the Rust language and live in the <code>bitcoindevkit/bdk</code> repository. The core BDK components are built upon the excellent <code>rust-bitcoin</code> and <code>rust-miniscript</code> crates.</p> <p>The BDK team also maintains the <code>bitcoindevkit/bdk-ffi</code> repository which provide cross-platform versions of the high level BDK APIs. Current supported platforms are: Kotlin (Android, Linux, macOS), Swift (iOS, macOS), and Python (Linux, macOS, Windows).</p> <p>Warning</p> <p>The BDK developers are in the process of rewriting major components of the software to be released in an upcoming <code>1.0</code> version. BDK 1.0 is still under active development and should be considered \"alpha\" quality. This means APIs may change and full testing and documentation has not been completed. For current status and release timeline please see the <code>bdk</code> project repository.</p> <p>The <code>bitcoindevkit/bdk-ffi</code> project has not yet been updated to use the new <code>BDK 1.0</code> crates. For current status and timeline for bdk-ffi, see the <code>bdk-ffi</code> project repository.</p>"},{"location":"architecture/design/","title":"Design of the BDK Ecosystem","text":""},{"location":"cookbook/descriptors/","title":"Working with Descriptors","text":"<p>BDK is a descriptor-first library. This page explores how to build them and how they interact with other standards like BIP-39 recovery phrases.</p> <p>Danger</p> <p>TODO: Standard notice of danger of working with private keys, generating entropy, etc.</p>"},{"location":"cookbook/descriptors/#using-descriptor-templates","title":"Using descriptor templates","text":"<p>BDK offers utility constructs called descriptor templates, which allow you to build descriptors for the four most common script types (BIP 44/49/84/86) with minimal effort.</p> <p>The following will build and print the full string representation of taproot (BIP-86) internal and external descriptors.</p> <pre><code>use bdk_wallet::bitcoin::bip32::Xpriv;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::bitcoin::secp256k1::rand;\nuse bdk_wallet::bitcoin::secp256k1::rand::RngCore;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::template::{Bip86, DescriptorTemplate};\n\nfn main() -&gt; () {\n    let mut seed: [u8; 32] = [0u8; 32];\n    rand::thread_rng().fill_bytes(&amp;mut seed);\n\n    let network: Network = Network::Testnet;\n    let xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\n    let (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External).build(network).unwrap();\n    let (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal).build(network).unwrap();\n\n    println!(\n        \"Descriptor: {:?}\",\n        descriptor.to_string_with_secret(&amp;key_map)\n    );\n    println!(\n        \"Change descriptor: {:?}\",\n        change_descriptor.to_string_with_secret(&amp;change_key_map)\n    );\n}\n</code></pre>"},{"location":"cookbook/wallet/electrum/","title":"Working with Electrum","text":"<p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-alpha.13</code> of bdk.</p>"},{"location":"cookbook/wallet/electrum/#1-create-a-new-rust-project","title":"1. Create a new Rust project","text":"<pre><code>cargo init electrumexample\ncd electrumexample\n</code></pre>"},{"location":"cookbook/wallet/electrum/#2-add-required-bdk-dependencies-to-your-cargotoml-file","title":"2. Add required bdk dependencies to your Cargo.toml file","text":"<pre><code>[package]\nname = \"electrumexample\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"=1.0.0-alpha.13\" }\nbdk_sqlite = { version = \"=0.2.0\" }\nbdk_electrum = { version = \"=0.15.0\" }\n</code></pre>"},{"location":"cookbook/wallet/electrum/#3-create-your-descriptors","title":"3. Create your descriptors","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on signet with the following BIP86 descriptors: <pre><code>tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)\ntr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/1/*)\n</code></pre></p>"},{"location":"cookbook/wallet/electrum/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"<pre><code>use bdk_wallet::wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::Wallet;\nuse bdk_electrum::{BdkElectrumClient, electrum_client};\nuse bdk_electrum::electrum_client::Client;\n\nconst STOP_GAP: usize = 50;\nconst BATCH_SIZE: usize = 5;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)#30pfz5ly\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/1/*)\";\n\nfn main() -&gt; () {\n    print_page_link(\"electrum/\");\n\n    let mut wallet: Wallet = Wallet::new(\n        EXTERNAL_DESCRIPTOR,\n        INTERNAL_DESCRIPTOR,\n        Network::Signet,\n    ).unwrap();\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n    // Generated address tb1p5nja3w87mc6xl5w3yy85evlg0qpyq2j4wzytazt4437nr37j2ajswm3ptl at index 0\n\n    // Syncing the wallet\n    let client: BdkElectrumClient&lt;Client&gt; = BdkElectrumClient::new(\n        electrum_client::Client::new(\"ssl://mempool.space:60602\").unwrap()\n    );\n\n    let full_scan_request = wallet.start_full_scan();\n    let mut update = client\n        .full_scan(full_scan_request, STOP_GAP, BATCH_SIZE, true).unwrap()\n        .with_confirmation_time_height_anchor(&amp;client).unwrap();\n\n    let now = std::time::UNIX_EPOCH.elapsed().unwrap().as_secs();\n    let _ = update.graph_update.update_last_seen_unconfirmed(now);\n\n    wallet.apply_update(update).unwrap();\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sats\", balance.total().to_sat());\n}\n</code></pre>"},{"location":"cookbook/wallet/esplora/","title":"Wallet with Esplora","text":"<p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-alpha.8</code> of bdk.</p>"},{"location":"cookbook/wallet/esplora/#create-a-new-rust-project","title":"Create a new Rust project","text":"<pre><code>cargo init esploraexample\ncd esploraexample\n</code></pre>"},{"location":"cookbook/wallet/esplora/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your Cargo.toml file","text":"<pre><code>[package]\nname = \"electrumexample\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk = { version = \"1.0.0-alpha.8\" }\nbdk_file_store = { version = \"0.8.0\" }\nbdk_esplora = { version = \"0.10.0\" }\n</code></pre>"},{"location":"cookbook/wallet/esplora/#3-create-your-wallet","title":"3. Create your wallet","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on testnet with the following BIP86 descriptor: <pre><code>tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)#30pfz5ly\n</code></pre></p> <p>A wallet is generic in its <code>Store</code>. For example, you can create a <code>Wallet&lt;()&gt;</code> which will have no persistence or a <code>Wallet&lt;bdk_file_store::store::Store&gt;</code> which will store to a flat file. The example below uses this flat file storage system.</p> Part 1: Wallet<pre><code>const DB_MAGIC: &amp;str = \"bdk_wallet_esplora_example\";\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\n\nuse std::collections::BTreeMap;\nuse std::io::Write;\nuse std::str::FromStr;\n\nuse bdk::wallet::{AddressIndex, AddressInfo, ChangeSet, Update};\nuse bdk::{KeychainKind, SignOptions};\nuse bdk::bitcoin::{Address, Network, Transaction};\nuse bdk::bitcoin::address::NetworkChecked;\nuse bdk::bitcoin::psbt::PartiallySignedTransaction;\nuse bdk::chain::{ConfirmationTimeHeightAnchor, TxGraph};\nuse bdk::Wallet;\nuse bdk::chain::local_chain::CheckPoint;\nuse bdk_esplora::{esplora_client, EsploraExt};\nuse bdk_file_store::Store;\n\nfn main() -&gt; () {\n    let db_path = std::env::current_dir().unwrap().join(\"esploraexample.db\");\n    let db = Store::&lt;bdk::wallet::ChangeSet&gt;::open_or_create_new(DB_MAGIC.as_bytes(), db_path).unwrap();\n    let external_descriptor = \"tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)#30pfz5ly\";\n\n    let mut wallet: Wallet&lt;Store&lt;ChangeSet&gt;&gt; = Wallet::new_or_load(\n        external_descriptor,\n        None,\n        db,\n        Network::Testnet,\n    ).unwrap();\n\n    let address: AddressInfo = wallet.try_get_address(AddressIndex::New).unwrap();\n\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n    // Generated address tb1p5nja3w87mc6xl5w3yy85evlg0qpyq2j4wzytazt4437nr37j2ajswm3ptl at index 0\n</code></pre>"},{"location":"cookbook/wallet/esplora/#4-sync-the-wallet","title":"4. Sync the wallet","text":"Part 2: Sync<pre><code>fn main() -&gt; () {\n\n    // --- snippet from part 1 above ---\n\n    let client = esplora_client::Builder::new(\"https://esplora.testnet.kuutamo.cloud\")\n        .build_blocking()\n        .unwrap();\n\n    let balance = wallet.get_balance();\n    println!(\"Wallet balance before syncing: {} sats\", balance.total());\n\n    let prev_tip: CheckPoint = wallet.latest_checkpoint();\n\n    let keychain_spks = wallet.all_unbounded_spk_iters();\n\n    let scan_result = client.full_scan(keychain_spks, STOP_GAP, PARALLEL_REQUESTS).unwrap();\n    let (graph_update, keychain_update): (TxGraph&lt;ConfirmationTimeHeightAnchor&gt;, BTreeMap&lt;KeychainKind, u32&gt;) = scan_result;\n\n    let missing_heights = graph_update.missing_heights(wallet.local_chain());\n    let chain_update = client.update_local_chain(prev_tip, missing_heights).unwrap();\n\n    let wallet_update = Update {\n        last_active_indices: keychain_update,\n        graph: graph_update,\n        chain: Some(chain_update),\n    };\n\n    wallet.apply_update(wallet_update).unwrap();\n    wallet.commit().unwrap();\n\n    let balance = wallet.get_balance();\n    println!(\"\\nWallet balance after syncing: {} sats\", balance.total());\n}\n</code></pre>"},{"location":"cookbook/wallet/esplora/#create-a-transaction","title":"Create a transaction","text":"Part 3: Transactions<pre><code>fn main() -&gt; () {\n\n    // --- snippet from part 1 above ---\n\n    // --- snippet from part 2 above ---\n\n    if balance.total() &lt; 5000 {\n        println!(\n            \"Please send at least 5000 sats to receiving address {}\",\n            address.address\n        );\n        std::process::exit(0);\n    }\n\n    let faucet_address: Address&lt;NetworkChecked&gt; = Address::from_str(\"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\").unwrap()\n        .require_network(Network::Testnet).unwrap();\n\n    let mut tx_builder = wallet.build_tx();\n    tx_builder\n        .add_recipient(faucet_address.script_pubkey(), 5000)\n        .enable_rbf();\n\n    let mut psbt: PartiallySignedTransaction = tx_builder.finish().unwrap();\n    let psbt_was_finalized = wallet.sign(&amp;mut psbt, SignOptions::default()).unwrap();\n    assert!(psbt_was_finalized);\n\n    let tx: Transaction = psbt.extract_tx();\n    client.transaction_broadcast(&amp;tx).unwrap();\n\n    println!(\"Tx broadcasted! txid: {}\", tx.txid());\n}\n</code></pre>"},{"location":"cookbook/wallet/rpc/","title":"Wallet with Bitcoin Core RPC","text":"<p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-alpha.8</code> of bdk.</p>"},{"location":"cookbook/wallet/rpc/#1-start-a-regtest-bitcoin-daemon","title":"1. Start a regtest bitcoin daemon","text":"<p>For this example you'll need to run a bitcoin core daemon locally in regtest mode. Here are some of the commands you'll need: <pre><code># In a shell dedicated to the bitcoin daemon \nbitcoind --chain=regtest\n\n# In a new shell dedicated to the bitcoin-cli\nbitcoin-cli --chain=regtest getblockchaininfo\n\nbitcoin-cli --chain=regtest createwallet mywallet\nbitcoin-cli --chain=regtest loadwallet mywallet\nbitcoin-cli --chain=regtest getnewaddress\n\n# Mine 101 blocks\nbitcoin-cli --chain=regtest generatetoaddress 101 &lt;address&gt;\n</code></pre></p>"},{"location":"cookbook/wallet/rpc/#2-create-a-new-rust-project","title":"2. Create a new Rust project","text":"<pre><code>cargo init rpcexample\ncd rpcexample\n</code></pre>"},{"location":"cookbook/wallet/rpc/#3-add-required-bdk-dependencies-to-your-cargotoml-file","title":"3. Add required bdk dependencies to your Cargo.toml file","text":"<pre><code>[package]\nname = \"rpcexample\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk = { version = \"=1.0.0-alpha.8\" }\nbdk_file_store = { version = \"=0.8.0\" }\nbdk_bitcoind_rpc = {  version = \"0.7.0\" }\n</code></pre>"},{"location":"cookbook/wallet/rpc/#4-create-your-wallet","title":"4. Create your wallet","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on testnet with the following BIP86 descriptor: <pre><code>tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)#30pfz5ly\n</code></pre></p> <p>A wallet is generic in its <code>Store</code>. For example, you can create a <code>Wallet&lt;()&gt;</code> which will have no persistence or a <code>Wallet&lt;bdk_file_store::store::Store&gt;</code> which will store to a flat file. The example below uses this flat file storage system.</p> Part 1: Wallet<pre><code>const DB_MAGIC: &amp;str = \"bdk_wallet_rpc_example\";\nconst COOKIE_FILE_PATH: &amp;str = \"&lt;path_to_your_regtest_bitcoin_core_cookie_file&gt;/.cookie\";\n\nuse bdk::wallet::{AddressIndex, AddressInfo, Balance, ChangeSet};\nuse bdk::bitcoin::{Block, Network, Transaction};\nuse bdk::{Wallet};\nuse bdk::chain::local_chain::CheckPoint;\nuse bdk_bitcoind_rpc::bitcoincore_rpc::{Auth, Client, RpcApi};\nuse bdk_bitcoind_rpc::{BlockEvent, Emitter};\nuse bdk_file_store::Store;\n\nfn main() -&gt; () {\n    print_page_link(\"rpc-wallet/\");\n\n    let db_path = std::env::current_dir().unwrap().join(\"rpcexample.db\");\n    let db = Store::&lt;bdk::wallet::ChangeSet&gt;::open_or_create_new(DB_MAGIC.as_bytes(), db_path).unwrap();\n    let external_descriptor = \"tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)#30pfz5ly\";\n\n    let mut wallet: Wallet&lt;Store&lt;ChangeSet&gt;&gt; = Wallet::new_or_load(\n        external_descriptor,\n        None,\n        db,\n        Network::Regtest,\n    ).unwrap();\n\n    let balance: Balance = wallet.get_balance();\n    println!(\"Wallet balance before syncing: {} sats\", balance.total());\n\n    let address: AddressInfo = wallet.try_get_address(AddressIndex::New).unwrap();\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n}\n</code></pre>"},{"location":"cookbook/wallet/rpc/#5-sync-the-wallet","title":"5. Sync the wallet","text":"<p>Syncing using a bitcoin core RPC client is called the block-by-block approach of syncing in BDK. You do this by creating an <code>Emitter</code> object and calling the <code>next_block()</code> method on it, which returns an <code>Option&lt;BlockEvent&lt;Block&gt;&gt;</code>. If this option is <code>None</code>, there are no new blocks to sync; if it's <code>Some</code>, you can apply this new block to your wallet by using the <code>wallet.apply_block_connected_to()</code> method. A similar workflow works for the mempool (see code below).</p> <p>To get the most of this example, work with a regtest that has at least 10 to 100 blocks in it.</p> Part 2: Sync<pre><code>fn main() -&gt; () {\n\n    // --- Snippet from part 1 above ---\n\n    let rpc_client: Client = Client::new(\n        \"http://127.0.0.1:18443\",\n        Auth::CookieFile(COOKIE_FILE_PATH.into())\n    ).unwrap();\n\n    let blockchain_info = rpc_client.get_blockchain_info().unwrap();\n    println!(\n        \"\\nConnected to Bitcoin Core RPC.\\nChain: {}\\nLatest block: {} at height {}\\n\",\n        blockchain_info.chain, blockchain_info.best_block_hash, blockchain_info.blocks,\n    );\n\n    let wallet_tip: CheckPoint = wallet.latest_checkpoint();\n    println!(\n        \"Current wallet tip is: {} at height {}\",\n        &amp;wallet_tip.hash(),\n        &amp;wallet_tip.height()\n    );\n\n    let mut emitter = Emitter::new(&amp;rpc_client, wallet_tip.clone(), wallet_tip.height());\n\n    println!(\"Syncing blocks...\");\n    loop {\n        let block_event: Option&lt;BlockEvent&lt;Block&gt;&gt; = emitter.next_block().unwrap();\n        let block = if block_event.is_none() {\n            break;\n        } else {\n            block_event.unwrap()\n        };\n        print!(\"{} \", block.block_height());\n\n        wallet.apply_block_connected_to(&amp;block.block, block.block_height(), block.connected_to()).unwrap();\n        wallet.commit().unwrap();\n    }\n    println!();\n\n    println!(\"Syncing mempool...\");\n    let mempool_emissions: Vec&lt;(Transaction, u64)&gt; = emitter.mempool().unwrap();\n\n    wallet.apply_unconfirmed_txs(mempool_emissions.iter().map(|(tx, time)| (tx, *time)));\n    wallet.commit().unwrap();\n\n    let balance = wallet.get_balance();\n    println!(\"Wallet balance after syncing: {} sats\", balance.total());\n}\n</code></pre> <p>Once you have synced the wallet once, mine a few new blocks using the bitcoin-cli and send coins to the address provided by the wallet and printed in the console. Upon running the example code again, your wallet will sync up the latest blocks and update its balance.</p>"},{"location":"getting-started/companion-code/","title":"Companion Codebase","text":"<p>This book comes with a series of code examples, one for each of the pages in the book. You can run any of the examples from your command line like so:</p> <pre><code>cd companion-code/esplora\ncargo run --bin esplora\n</code></pre> <p>Alternatively, if you have the just tool installed, you can use: <pre><code>cd companion-code\njust esplora\n</code></pre></p>"},{"location":"getting-started/getting-started/","title":"Getting Started","text":""},{"location":"getting-started/getting-started/#install-rust","title":"Install Rust","text":"<p>See the Rust Getting Started page to install the Rust development tools.</p>"},{"location":"getting-started/getting-started/#using-bdk-in-a-rust-project","title":"Using BDK in a Rust project","text":"<p>Follow these steps to use BDK in your own rust project with the async <code>esplora</code> blockchain client.</p> <p>Tip</p> <p>For now, we suggest using the latest <code>master</code> branch versions of BDK crates. As an example, for BDK:</p> <pre><code>cargo add bdk\n</code></pre> <ol> <li>Create a new Rust project:</li> </ol> <pre><code>cargo init my_bdk_app\ncd my_bdk_app\n</code></pre> <ol> <li>Add <code>bdk</code> to your <code>Cargo.toml</code> file. Find the latest <code>bdk@1</code> release on <code>crates.io</code>, for example:</li> </ol> <pre><code>cargo add bdk@1.0.0-alpha.8\n</code></pre> <ol> <li>Add other required dependencies:</li> </ol> <pre><code>cargo add bdk_esplora@0.10.0\ncargo add bdk_file_store@0.8.0\n</code></pre> <p>See the Wallet with Electrum Example page for how to create and sync a wallet.</p>"},{"location":"getting-started/organization/","title":"Project Organization","text":"<p>Within the <code>bitcoindevkit/bdk</code> repository the BDK team maintains a suite of rust crates which provide both an easy-to-use high level API and powerful lower level components to used when building more advanced bitcoin software.</p> <p>The project is split up into several crates in the <code>/crates</code> directory:</p> <ul> <li><code>bdk</code>: Contains the central high level <code>Wallet</code> type    that is built from the low-level mechanisms provided by the other components</li> <li><code>chain</code>: Tools for storing and indexing chain data</li> <li><code>file_store</code>: A (experimental) persistence backend for storing chain data in a single file.</li> <li><code>esplora</code>: Extends the <code>esplora-client</code>    crate with methods to fetch chain data from an esplora HTTP server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>electrum</code>: Extends the <code>electrum-client</code>    crate with methods to fetch chain data from an electrum server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> </ul>"}]}